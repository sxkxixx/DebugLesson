package ru.urfu;

/**
 * Создание и инициализация двумерного массива. Считает сумму его элементов.
 *
 * @author vpyzhyanov
 * @since 22.05.2023
 */
public class MatrixInitializer {
    private static final int SIZE = 100;
    private long sum = 0;

    /**
     * TODO выполнить задание:
     * <p><b>Задание должно быть выполнено с использованием возможностей отладки.
     * Изменять код нельзя! (кроме задания на исправление ошибки)</b></p>
     * <p><b>Логирование нужно применять <u>только</u> в последнем задании!</b></p>
     * <ol>
     *     <li>Найти значение sum, при котором происходит исключение
     *         (поставить breakpoint на возникающее исключение и воспользоваться стеком вызовов)</li>
     *         Ответ: -4390925508
     *
     *     <li>Исправить ошибку <b>Важно исправить именно ошибку в существующей логике,
     *         а не добавлять свою логику!</b><br>
     *         В качестве ответа надо написать какое изменение вы сделали.</li>
     *         <p>Ответ: В 62-ой строке измений индекс [i + 1] -> [i], именно в этой строке
     *         возникало исключение IndexOutOfBoundsException</p>
     *
     *     <li>Найти значение value перед добавлением значения элемента массива с индексами [95][30]
     *         (нужно использовать условия)</li>
     *         <p>Ответ: value = 43</p>
     *
     *     <li>Вычислить значение выражения (up - left + 1) * j / 4 для i = 57, j = 28
     *         (для вычисления нужно использовать окно EvaluateExpression [Alt + F8])</li>
     *         <p>Ответ: (up - left + 1) * j / 4 = <b>7</b></p>
     *
     *     <li>Добавить breakpoint в метод {@link #getValue(long[][], int, int)},
     *         нужно остановиться только когда значение sum станет больше 2300
     *         (нужно в методе test добавить breakpoint (на нём останавливаться не нужно),
     *         после которого должен сработать ранее созданный breakpoint).
     *         Найдите значение выражения up + left
     *         (для вычисления нужно использовать окно EvaluateExpression [Alt + F8])</li>
     *         <p>Ответ: up + left = 7</p>
     *
     *     <li>Вывести в лог значение sum, когда i == j
     *         (<b>Код изменять нельзя! И на точке не останавливаемся!</b>)
     *         Найти сколько раз встречается значение sup по модулю меньше 10 000
     *         (ничего автоматизировать не нужно, достаточно просто посмотреть, что выведено в лог)</li>
     *         <p>Ответ: sum по модулю меньше 10_000 ровно 3 раза</p>
     * </ol>
     */
    public void test() {
        sum = 0;
        long[][] matrix = new long[SIZE][SIZE];
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                long value = getValue(matrix, i, j);
                matrix[i][j] = value;
                sum += value;
            }
        }

        System.out.println("sum = " + sum);
    }

    private static long getValue(long[][] matrix, int i, int j) {
        long up = i > 0
                ? matrix[i - 1][j]
                : 0L;
        long left = j > 0
                ? matrix[i][j - 1]
                : 1L;
        return ((left - up + i) * (j / 10 + 1)) / 8;
    }
}
